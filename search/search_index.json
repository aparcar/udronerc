{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"udrone - QA done right Udrone is a system that allows you to remotely control N drones. The N drones can be sent a number of different commands. Based on these commands the drone will perform a number of actions and report the result back to the drone host controller. The system consists of a number of files on the controller side. udronerc.py - the core component. This code establishes a communication channel to the drone. qa.py - this is a wrapper for udrone.py that allows us to write test in json syntax and run them in a sane manner *.yml - this is a collection of predefined tests, that the drone can run Setup The following steps explain how to setup an udrone environment. Where do I get udrone Checkout the latest version via the following command $ git clone https://github.com/blogic/udrone How do I setup udrone software udrone is easy to setup. All custom information is stored in a central file called config.py $ cat config.py ifname: eth0 # the interface used to talk to the drones Hardware setup In addition to the device under testing (DUT) you will need N drones. A drone is a OpenWrt router with the udrone package installed. Once you have all devices, you need to set them up in 1 of the following ways. LAPTOP (eth0) -> (LAN) DRONE (WAN) -> (LAN) DUT (WAN) -> BACKEND LAPTOP (eth0) -> (LAN) DRONE (WIFI) -> (WIFI) DUT (WAN) -> BACKEND If you want to use more than just 1 Drone you will need to switches between LAPTOP/DRONE and DRONE/DUT . As a backend you will need, depending on the test: AP/PPPoE Server/DHCP/DNS/... Run tests The simplest test is the connectivity test. This will make the drone grab an IPV4 using DHCP from the DUT and wget http://openwrt.org/index.html . $ ./qa.py test/connectivity.yml Once all test are run, the qa tool will report back if the test passed or failed. Definition of test cases So, lets start by looking at the format of the json file. The basic layout of any json based test description is as follows { \"id\":\"The ID of the test\", \"desc\":\"The description of the test\", \"drones\":the_number_of_drones, \"test\":[ the actual test case go here ], } Within the test:[] entity we will start to define all the different test cases that want to run as part of this test. A typical testcase would look like this { \"desc\":\"use fatserver calls to set public_essid)\", \"repeat\":how_often_we_want_to_run_the_test, \"first\":loop_from_first, \"last\":loop_to_last, \"sleep\":how_many_seconds_to_sleep_after_the_test, \"cmd\":[ the actual commands to be called go here ], } If last/first is set, repeat will be ignored. Within the cmd:[] entity we define the actual real commands that we want the drone to execute as part of the test. Consider these to be a reduced to the smallest denominator of commands called (or in other terms, these are risc commands and not cisc). The command can have a verity of functions, from setting local and remote network settings, doing a generic sleep, talking to the DUT, doing random networkery, ... Lets start by looking at a single row [ \"ACTION\", .................. ] Every line start with a ACTION. Depending on the real ACTION to take, we can have N parameters following the ACTON call. Actions can be of 3 types. So lets look at 3 lines { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } sleep - sleep # this makes the system wait 5 seconds [ \"sleep\", 5 ] drone - send commands to drone # we want to send a command to a drone, whose id is 1, the commands id is # \"webui_auth\" and we pass the payload {\"pass\":\"foobar\"}. if the call fails # to return within 300s, we raise a failure/exception [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], $complex - when ACTIONS become to complex to be handled by the \"drone\" call, we can add additional handlers inside qa.py to abstract the complexion away abit. # run the complex command essid. this sets the essid of drone 1 to # foorandom and uses 12345321234 as a passphrase this call is complex as we # don't only send a command, but 2 and then poll for their completion. # Completion is detected by polling the network status reporting info from # the DUT [ \"essid\", 1, \"foorandom\", \"12345321234\" ] All complex functions are located inside qa.py A full test would look like this: { \"id\":\"test123\", \"desc\":\"A demo testcase.\", \"drones\":1, \"test\": [ { \"desc\":\"log into webui and set essid\", \"repeat\":1, \"sleep\":1, \"cmd\": [ { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } ], }, ], } Using iterations and substitution As described above a test set can be repeated N times (repeat: 4). To reflect the N iterations within the test we can use variable substitution. To do so, simply place $iterate inside any parameter section and it will get magically replaced by the backend. A simple iteration example would look like this. { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"repeat example\", \"repeat\":4, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 1 COMMENT Iteration 1 RUN \"iterate\" - iteration 2 COMMENT Iteration 2 RUN \"iterate\" - iteration 3 COMMENT Iteration 3 RUN \"iterate\" - iteration 4 COMMENT Iteration 4 { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"first->last example\", \"first\":4, \"last\":\"6, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 4 COMMENT Iteration 4 RUN \"iterate\" - iteration 5 COMMENT Iteration 5 RUN \"iterate\" - iteration 6 COMMENT Iteration 6 In addition we can use variable substation. To do so simply create a new value inside conf.py and then reference it inside your json code [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] List of all complex calls Generally we use complex calls whenever we need to not just send data but wait for a status. # set a static IP on drone 1 [ \"static\", 1, \"192.168.10.2\", \"255.255.255.0\" ] # set essid of drone 1 to wifitest and wpa key to foobar [ \"essid\", 1, \"wifitest\", \"foobar\" ] # trigger drone 1 [ \"dhcp\", 1 ] # sleep 5 seconds [ \"sleep\", 1 ] # fail is a test result inverter. it switces a result true<->false [ \"fail\", \"dhcp\", 1 ] # this will trigger qa.py to print a comment in the log [ \"comment\", \"foooooobar\" ] # this will cause drone 1 to try and ping a remote url [ \"ping\", 1, \"192.168.10.1\" ] # this will check if the IP received in a dhcp reply received by drone 1 # matches certain criterions. [ \"checkip\", 1, \"192.168.10.\" ] As netmasks are limited to 32 and or not always obvious which once are valid, we have 2 special complex calls to handle this. Netmasks are always indexed by an id rather than a absolute mask. # this will set the netmask on drone 1 to Mask index #1 [ \"setnetmask\", 1 ] # this will check if the netmask received in a dhcp reply received by drone 1 # matches certain criterions of Mask index #1 [ \"checknetmask\", 1 ] Finally we have a complex call that we use as our entry point for RPC on a Drone # send a drone RPC call to drone 1. [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ], List of all drone calls # dns_flood - do mass dns resolving [ \"drone\", 1, \"dns_flood\", [\"www.google.de\", \"www.google.com\"] # download - download a file and check its size [ \"drone\", 1, \"download\", {\"url\":\"http://dev.phrozen.org/test\", \"repeat\":\"4\", \"size\":\"1048576\"}, 300 ] # fatserver - simulate a fatserver call - this requires a DUT with dev mode enabled [ \"drone\", 1, \"fatserver\", {\"host\":\"192.168.10.1\", \"payload\":\"json|{\\\"cmd\\\":\\\"setwpapassword\\\", \\\"val\\\":\\\"12345321234\\\" }\" } ] # cloudlogin - log into a cloudspot using http redirects [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] # cloudwispr - log into a cloudspot using wispr # cloudlogout - log of the cloud service [ \"drone\", 1, \"cloudlogout\" ] # webui_auth - tell the drone to log into the DUTs webui [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ] # webui_rpc - send a webui rpc call (these are identical to the ones used by the normal webui) [ \"drone\", 1, \"webui_rpc\", { \"set\":\"passwd\", \"vals\":{\"passwd1\":\"fooooooooo\" } } ], # webui_deauth - log off the webui [ \"drone\", 1, \"webui_deauth\" ] # webui_ip - use a different webui ip than 192.168.10.1 [ \"drone\", 1, \"webui_ip\", {\"ipaddr\":\"169.254.255.1\"}, 300 ], # uci_dump - get [ \"drone\", 1, \"uci_dump\", {\"package\":\"cloud\", \"section\":\"state\", \"state\":1 }, 300 ], The following calls exist but are currently unused getifaddrs - get a list of all netdevs inclusive the ipaddr ... readfile - read a random file from the drones FS reset - reboot the drone sysinfo - get system resource usage system - execute a random system call on the drone uci_dump - get some use values uci_replace - uci magic upgrade - FW upgrade of the Drone","title":"udrone - QA done right"},{"location":"#udrone-qa-done-right","text":"Udrone is a system that allows you to remotely control N drones. The N drones can be sent a number of different commands. Based on these commands the drone will perform a number of actions and report the result back to the drone host controller. The system consists of a number of files on the controller side. udronerc.py - the core component. This code establishes a communication channel to the drone. qa.py - this is a wrapper for udrone.py that allows us to write test in json syntax and run them in a sane manner *.yml - this is a collection of predefined tests, that the drone can run","title":"udrone - QA done right"},{"location":"#setup","text":"The following steps explain how to setup an udrone environment.","title":"Setup"},{"location":"#where-do-i-get-udrone","text":"Checkout the latest version via the following command $ git clone https://github.com/blogic/udrone","title":"Where do I get udrone"},{"location":"#how-do-i-setup-udrone-software","text":"udrone is easy to setup. All custom information is stored in a central file called config.py $ cat config.py ifname: eth0 # the interface used to talk to the drones","title":"How do I setup udrone software"},{"location":"#hardware-setup","text":"In addition to the device under testing (DUT) you will need N drones. A drone is a OpenWrt router with the udrone package installed. Once you have all devices, you need to set them up in 1 of the following ways. LAPTOP (eth0) -> (LAN) DRONE (WAN) -> (LAN) DUT (WAN) -> BACKEND LAPTOP (eth0) -> (LAN) DRONE (WIFI) -> (WIFI) DUT (WAN) -> BACKEND If you want to use more than just 1 Drone you will need to switches between LAPTOP/DRONE and DRONE/DUT . As a backend you will need, depending on the test: AP/PPPoE Server/DHCP/DNS/...","title":"Hardware setup"},{"location":"#run-tests","text":"The simplest test is the connectivity test. This will make the drone grab an IPV4 using DHCP from the DUT and wget http://openwrt.org/index.html . $ ./qa.py test/connectivity.yml Once all test are run, the qa tool will report back if the test passed or failed.","title":"Run tests"},{"location":"#definition-of-test-cases","text":"So, lets start by looking at the format of the json file. The basic layout of any json based test description is as follows { \"id\":\"The ID of the test\", \"desc\":\"The description of the test\", \"drones\":the_number_of_drones, \"test\":[ the actual test case go here ], } Within the test:[] entity we will start to define all the different test cases that want to run as part of this test. A typical testcase would look like this { \"desc\":\"use fatserver calls to set public_essid)\", \"repeat\":how_often_we_want_to_run_the_test, \"first\":loop_from_first, \"last\":loop_to_last, \"sleep\":how_many_seconds_to_sleep_after_the_test, \"cmd\":[ the actual commands to be called go here ], } If last/first is set, repeat will be ignored. Within the cmd:[] entity we define the actual real commands that we want the drone to execute as part of the test. Consider these to be a reduced to the smallest denominator of commands called (or in other terms, these are risc commands and not cisc). The command can have a verity of functions, from setting local and remote network settings, doing a generic sleep, talking to the DUT, doing random networkery, ... Lets start by looking at a single row [ \"ACTION\", .................. ] Every line start with a ACTION. Depending on the real ACTION to take, we can have N parameters following the ACTON call. Actions can be of 3 types. So lets look at 3 lines { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } sleep - sleep # this makes the system wait 5 seconds [ \"sleep\", 5 ] drone - send commands to drone # we want to send a command to a drone, whose id is 1, the commands id is # \"webui_auth\" and we pass the payload {\"pass\":\"foobar\"}. if the call fails # to return within 300s, we raise a failure/exception [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], $complex - when ACTIONS become to complex to be handled by the \"drone\" call, we can add additional handlers inside qa.py to abstract the complexion away abit. # run the complex command essid. this sets the essid of drone 1 to # foorandom and uses 12345321234 as a passphrase this call is complex as we # don't only send a command, but 2 and then poll for their completion. # Completion is detected by polling the network status reporting info from # the DUT [ \"essid\", 1, \"foorandom\", \"12345321234\" ] All complex functions are located inside qa.py A full test would look like this: { \"id\":\"test123\", \"desc\":\"A demo testcase.\", \"drones\":1, \"test\": [ { \"desc\":\"log into webui and set essid\", \"repeat\":1, \"sleep\":1, \"cmd\": [ { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } ], }, ], }","title":"Definition of test cases"},{"location":"#using-iterations-and-substitution","text":"As described above a test set can be repeated N times (repeat: 4). To reflect the N iterations within the test we can use variable substitution. To do so, simply place $iterate inside any parameter section and it will get magically replaced by the backend. A simple iteration example would look like this. { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"repeat example\", \"repeat\":4, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 1 COMMENT Iteration 1 RUN \"iterate\" - iteration 2 COMMENT Iteration 2 RUN \"iterate\" - iteration 3 COMMENT Iteration 3 RUN \"iterate\" - iteration 4 COMMENT Iteration 4 { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"first->last example\", \"first\":4, \"last\":\"6, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 4 COMMENT Iteration 4 RUN \"iterate\" - iteration 5 COMMENT Iteration 5 RUN \"iterate\" - iteration 6 COMMENT Iteration 6 In addition we can use variable substation. To do so simply create a new value inside conf.py and then reference it inside your json code [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ]","title":"Using iterations and substitution"},{"location":"#list-of-all-complex-calls","text":"Generally we use complex calls whenever we need to not just send data but wait for a status. # set a static IP on drone 1 [ \"static\", 1, \"192.168.10.2\", \"255.255.255.0\" ] # set essid of drone 1 to wifitest and wpa key to foobar [ \"essid\", 1, \"wifitest\", \"foobar\" ] # trigger drone 1 [ \"dhcp\", 1 ] # sleep 5 seconds [ \"sleep\", 1 ] # fail is a test result inverter. it switces a result true<->false [ \"fail\", \"dhcp\", 1 ] # this will trigger qa.py to print a comment in the log [ \"comment\", \"foooooobar\" ] # this will cause drone 1 to try and ping a remote url [ \"ping\", 1, \"192.168.10.1\" ] # this will check if the IP received in a dhcp reply received by drone 1 # matches certain criterions. [ \"checkip\", 1, \"192.168.10.\" ] As netmasks are limited to 32 and or not always obvious which once are valid, we have 2 special complex calls to handle this. Netmasks are always indexed by an id rather than a absolute mask. # this will set the netmask on drone 1 to Mask index #1 [ \"setnetmask\", 1 ] # this will check if the netmask received in a dhcp reply received by drone 1 # matches certain criterions of Mask index #1 [ \"checknetmask\", 1 ] Finally we have a complex call that we use as our entry point for RPC on a Drone # send a drone RPC call to drone 1. [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ],","title":"List of all complex calls"},{"location":"#list-of-all-drone-calls","text":"# dns_flood - do mass dns resolving [ \"drone\", 1, \"dns_flood\", [\"www.google.de\", \"www.google.com\"] # download - download a file and check its size [ \"drone\", 1, \"download\", {\"url\":\"http://dev.phrozen.org/test\", \"repeat\":\"4\", \"size\":\"1048576\"}, 300 ] # fatserver - simulate a fatserver call - this requires a DUT with dev mode enabled [ \"drone\", 1, \"fatserver\", {\"host\":\"192.168.10.1\", \"payload\":\"json|{\\\"cmd\\\":\\\"setwpapassword\\\", \\\"val\\\":\\\"12345321234\\\" }\" } ] # cloudlogin - log into a cloudspot using http redirects [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] # cloudwispr - log into a cloudspot using wispr # cloudlogout - log of the cloud service [ \"drone\", 1, \"cloudlogout\" ] # webui_auth - tell the drone to log into the DUTs webui [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ] # webui_rpc - send a webui rpc call (these are identical to the ones used by the normal webui) [ \"drone\", 1, \"webui_rpc\", { \"set\":\"passwd\", \"vals\":{\"passwd1\":\"fooooooooo\" } } ], # webui_deauth - log off the webui [ \"drone\", 1, \"webui_deauth\" ] # webui_ip - use a different webui ip than 192.168.10.1 [ \"drone\", 1, \"webui_ip\", {\"ipaddr\":\"169.254.255.1\"}, 300 ], # uci_dump - get [ \"drone\", 1, \"uci_dump\", {\"package\":\"cloud\", \"section\":\"state\", \"state\":1 }, 300 ], The following calls exist but are currently unused getifaddrs - get a list of all netdevs inclusive the ipaddr ... readfile - read a random file from the drones FS reset - reboot the drone sysinfo - get system resource usage system - execute a random system call on the drone uci_dump - get some use values uci_replace - uci magic upgrade - FW upgrade of the Drone","title":"List of all drone calls"},{"location":"development/setup/","text":"Test setup The following will guide through setting up two kinds of development environments. The primer is for local development of udrone only as the running node is emulated with limited capabilities (No WiFi, no WAN interface). The second setup requires a total of four devices of which (at least) three run OpenWrt. The second setup allows real device testing. Before explaining the setup itself basic steps are described to setup drones. Compiling udrone client package Add the feed-prpl to you local build environment. See the README.md on how to do so. Install the udrone package by running ./scripts/feeds install udrone in your local build environment. Compile the package alone via make package/udrone/compile . The package is found in an architecture specific folder in ./bin/packages/<arch>/feed-prpl/ . Install the package on your drones. Local setup The local setup runs a single drone within a Docker container which is controllable via the developers host computer. This setup does not include a device of testing (DOT) and it's only purpose is to see if the udrone client software and udronerc remote controller work as expected. Development drone To compile a development drone run make menuconfig and select the x86/64 architecture. Select the udrone package in the Development section. Once compiled you can run the node within a docker container using the docker-run-rootfs.sh script. ./scripts/docker-run-rootfs.sh --network Be sure to enable the network via --network else the node has no attached network interfaces to communicate with the controller. Run ps in the opened terminal to verify udrone is started. Alternatively it is possible to run the following two command to get all udrone status messages printed to stdout : /etc/init.d/udrone stop udrone eth0 Remote controller setup The remote controller is a Python package with some dependencies outside the Python standard library. It is installable via the following commands which automatically install all required packages: git clone https://github.com/aparcar/udronerc.git cd udronerc/ python3 -m venv . source ./bin/activate pip install -e . Using the pip install -e . installs udronerc in the current folder allowing to perform changes without the need of reinstalling the package.","title":"Test setup"},{"location":"development/setup/#test-setup","text":"The following will guide through setting up two kinds of development environments. The primer is for local development of udrone only as the running node is emulated with limited capabilities (No WiFi, no WAN interface). The second setup requires a total of four devices of which (at least) three run OpenWrt. The second setup allows real device testing. Before explaining the setup itself basic steps are described to setup drones.","title":"Test setup"},{"location":"development/setup/#compiling-udrone-client-package","text":"Add the feed-prpl to you local build environment. See the README.md on how to do so. Install the udrone package by running ./scripts/feeds install udrone in your local build environment. Compile the package alone via make package/udrone/compile . The package is found in an architecture specific folder in ./bin/packages/<arch>/feed-prpl/ . Install the package on your drones.","title":"Compiling udrone client package"},{"location":"development/setup/#local-setup","text":"The local setup runs a single drone within a Docker container which is controllable via the developers host computer. This setup does not include a device of testing (DOT) and it's only purpose is to see if the udrone client software and udronerc remote controller work as expected.","title":"Local setup"},{"location":"development/setup/#development-drone","text":"To compile a development drone run make menuconfig and select the x86/64 architecture. Select the udrone package in the Development section. Once compiled you can run the node within a docker container using the docker-run-rootfs.sh script. ./scripts/docker-run-rootfs.sh --network Be sure to enable the network via --network else the node has no attached network interfaces to communicate with the controller. Run ps in the opened terminal to verify udrone is started. Alternatively it is possible to run the following two command to get all udrone status messages printed to stdout : /etc/init.d/udrone stop udrone eth0","title":"Development drone"},{"location":"development/setup/#remote-controller-setup","text":"The remote controller is a Python package with some dependencies outside the Python standard library. It is installable via the following commands which automatically install all required packages: git clone https://github.com/aparcar/udronerc.git cd udronerc/ python3 -m venv . source ./bin/activate pip install -e . Using the pip install -e . installs udronerc in the current folder allowing to perform changes without the need of reinstalling the package.","title":"Remote controller setup"},{"location":"reference/dronegroup/","text":"The DroneGroup class stores client drones and offer functions to commands on all drones of a group. DroneGroup assign ( self , max_nodes = 1 , min_nodes = 1 , board = 'generic' ) Assign nodes to group Parameters: Name Type Description Default max_nodes int maximal number of nodes required 1 min_nodes int mimimal number of nodes required 1 board str limit assignment to specific board 'generic' Returns: Type Description list list: new member os group Source code in udronerc/dronegroup.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def assign ( self , max_nodes : int = 1 , min_nodes : int = 1 , board : str = \"generic\" ) -> list : \"\"\" Assign nodes to group Args: max_nodes (int): maximal number of nodes required min_nodes (int): mimimal number of nodes required board (str): limit assignment to specific board Returns: list: new member os group \"\"\" # ingroup = self.host.whois(self.groupid, max_nodes, board=board) # print(ingroup) # if max_nodes >= len(ingroup) >= min_nodes: # return list(ingroup.keys()) available = list ( self . host . whois ( UDRONE_GROUP_DEFAULT , max_nodes , board = board ) . keys () )[: max_nodes ] if len ( available ) < min_nodes : raise DroneNotFoundError (( ENOENT , \"You must construct additional drones\" )) new_members = self . engage ( available ) if len ( new_members ) < min_nodes : max_nodes -= len ( new_members ) available = list ( self . host . whois ( UDRONE_GROUP_DEFAULT , max_nodes ) . keys ())[ : max_nodes ] new_members += self . engage ( available ) if len ( new_members ) < min_nodes : if len ( new_members ) > 0 : # Rollback self . host . call_multi ( new_members , None , \"!reset\" , None , \"status\" ) raise DroneNotFoundError (( ENOENT , \"You must construct additional drones\" )) return new_members engage ( self , nodes ) Invite nodes by ID Source code in udronerc/dronegroup.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def engage ( self , nodes ): \"\"\"Invite nodes by ID \"\"\" ans = self . host . call_multi ( nodes , None , \"!assign\" , { \"group\" : self . groupid , \"seq\" : self . seq }, \"status\" ) members = [] for member , answer in ans . items (): print ( member , answer ) if answer [ \"data\" ][ \"code\" ] == 0 : members . append ( member ) print ( members ) self . members |= set ( members ) return members","title":"Dronegroup"},{"location":"reference/dronegroup/#udronerc.dronegroup","text":"","title":"udronerc.dronegroup"},{"location":"reference/dronegroup/#udronerc.dronegroup.DroneGroup","text":"","title":"DroneGroup"},{"location":"reference/dronegroup/#udronerc.dronegroup.DroneGroup.assign","text":"Assign nodes to group Parameters: Name Type Description Default max_nodes int maximal number of nodes required 1 min_nodes int mimimal number of nodes required 1 board str limit assignment to specific board 'generic' Returns: Type Description list list: new member os group Source code in udronerc/dronegroup.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def assign ( self , max_nodes : int = 1 , min_nodes : int = 1 , board : str = \"generic\" ) -> list : \"\"\" Assign nodes to group Args: max_nodes (int): maximal number of nodes required min_nodes (int): mimimal number of nodes required board (str): limit assignment to specific board Returns: list: new member os group \"\"\" # ingroup = self.host.whois(self.groupid, max_nodes, board=board) # print(ingroup) # if max_nodes >= len(ingroup) >= min_nodes: # return list(ingroup.keys()) available = list ( self . host . whois ( UDRONE_GROUP_DEFAULT , max_nodes , board = board ) . keys () )[: max_nodes ] if len ( available ) < min_nodes : raise DroneNotFoundError (( ENOENT , \"You must construct additional drones\" )) new_members = self . engage ( available ) if len ( new_members ) < min_nodes : max_nodes -= len ( new_members ) available = list ( self . host . whois ( UDRONE_GROUP_DEFAULT , max_nodes ) . keys ())[ : max_nodes ] new_members += self . engage ( available ) if len ( new_members ) < min_nodes : if len ( new_members ) > 0 : # Rollback self . host . call_multi ( new_members , None , \"!reset\" , None , \"status\" ) raise DroneNotFoundError (( ENOENT , \"You must construct additional drones\" )) return new_members","title":"assign()"},{"location":"reference/dronegroup/#udronerc.dronegroup.DroneGroup.engage","text":"Invite nodes by ID Source code in udronerc/dronegroup.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def engage ( self , nodes ): \"\"\"Invite nodes by ID \"\"\" ans = self . host . call_multi ( nodes , None , \"!assign\" , { \"group\" : self . groupid , \"seq\" : self . seq }, \"status\" ) members = [] for member , answer in ans . items (): print ( member , answer ) if answer [ \"data\" ][ \"code\" ] == 0 : members . append ( member ) print ( members ) self . members |= set ( members ) return members","title":"engage()"},{"location":"reference/dronehost/","text":"The DroneHost class offers functions to communiacte with drones and receive their responses. DroneHost call ( self , to , seq , msg_type , data = None , resp_type = None , expect = None ) Send data to drone and receive response Parameters: Name Type Description Default to str selected group required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None expect list list of drones expected to anser None Returns: Type Description dict dict: received message from drones Source code in udronerc/dronehost.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def call ( self , to : str , seq : int , msg_type : str , data : dict = None , resp_type : str = None , expect : list = None , ) -> dict : \"\"\" Send data to drone and receive response Args: to (str): selected group seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type expect (list): list of drones expected to anser Returns: dict: received message from drones \"\"\" if not seq : seq = self . genseq () answers = {} for timeout in self . resent_strategy : self . send ( to , seq , msg_type , data ) self . recv_until ( answers , seq , resp_type , timeout , expect ) if expect is not None and len ( expect ) == 0 : break return answers call_multi ( self , nodes , seq , msg_type , data = None , resp_type = None ) Send data to multiple drones and receive responses Parameters: Name Type Description Default nodes list selected drones required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None Returns: Type Description dict dict: received message from drones Source code in udronerc/dronehost.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def call_multi ( self , nodes : list , seq : int , msg_type : str , data : dict = None , resp_type : str = None , ) -> dict : \"\"\" Send data to multiple drones and receive responses Args: nodes (list): selected drones seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type Returns: dict: received message from drones \"\"\" if not seq : seq = self . genseq () answers = {} for timeout in self . resent_strategy : for node in nodes : self . send ( node , seq , msg_type , data ) self . recv_until ( answers , seq , resp_type , timeout , nodes ) if len ( nodes ) == 0 : break return answers genseq ( self ) Generate random sequence number Returns: Type Description int int: generated sequence Source code in udronerc/dronehost.py 65 66 67 68 69 70 71 72 def genseq ( self ) -> int : \"\"\" Generate random sequence number Returns: int: generated sequence \"\"\" return struct . unpack ( \"=I\" , os . urandom ( 4 ))[ 0 ] % 2000000000 get_ip_address ( self , interface ) Get IP of a local interface Parameters: Name Type Description Default interface str name of local interface required Returns: Type Description str str: IP address of interface Source code in udronerc/dronehost.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_ip_address ( self , interface : str ) -> str : \"\"\" Get IP of a local interface Args: interface (str): name of local interface Returns: str: IP address of interface \"\"\" s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) return socket . inet_ntoa ( fcntl . ioctl ( s . fileno (), 0x8915 , struct . pack ( \"256s\" , interface [: 15 ] . encode ( \"utf-8\" )), # SIOCGIFADDR )[ 20 : 24 ] ) Group ( self , groupid , absolute = False ) Create new group Parameters: Name Type Description Default groupid str Name of the new group required absolute bool Prefix group name with hostid False Returns: Type Description Group Newly created group Source code in udronerc/dronehost.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def Group ( self , groupid : str , absolute : bool = False ): \"\"\"Create new group Args: groupid (str): Name of the new group absolute (bool): Prefix group name with hostid Returns: Group: Newly created group \"\"\" if not absolute : groupid = f \" { self . hostid } _ { groupid } \" group = DroneGroup ( self , groupid ) self . groups . append ( group ) return group recv ( self , seq , msg_type = None ) Recevie messages from drones Parameters: Name Type Description Default seq int sequence number required msg_type str type of message to receive None Returns: Type Description dict dict: received message from drone Source code in udronerc/dronehost.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def recv ( self , seq : int , msg_type : str = None ) -> dict : \"\"\" Recevie messages from drones Args: seq (int): sequence number msg_type (str): type of message to receive Returns: dict: received message from drone \"\"\" while True : try : msg = json . loads ( self . socket . recv ( self . maxsize )) if ( msg [ \"from\" ] and msg [ \"type\" ] and msg [ \"to\" ] == self . hostid and ( not msg_type or msg [ \"type\" ] == msg_type ) and ( not seq or msg [ \"seq\" ] == seq ) ): logger . debug ( \"Received: %s \" , str ( msg )) return msg except Exception as e : if isinstance ( e , socket . error ) and e . errno == EWOULDBLOCK : return None recv_until ( self , answers , seq , msg_type = None , timeout = 1 , expect = None ) Recevie messages from drones until requirement is fulfilled Parameters: Name Type Description Default answers dict Empty dict to be filled with received answers required seq int sequence number required msg_type str type of message to receive None timeout int number of seconds before receiving timeouts 1 expect list list of drones expected to anser None Source code in udronerc/dronehost.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def recv_until ( self , answers : dict , seq : int , msg_type : str = None , timeout : int = 1 , expect : list = None , ): \"\"\" Recevie messages from drones until requirement is fulfilled Args: answers (dict): Empty dict to be filled with received answers seq (int): sequence number msg_type (str): type of message to receive timeout (int): number of seconds before receiving timeouts expect (list): list of drones expected to anser \"\"\" logger . debug ( \"Receiving replies for seq %i for %.1f secs expecting %s \" , seq , timeout , expect , ) start = time . time () now = start while ( ( now - start ) >= 0 and ( now - start ) < timeout and ( expect is None or len ( expect ) > 0 ) ): self . poll . poll (( timeout - ( now - start )) * 1000 ) while True : msg = self . recv ( seq , msg_type ) if msg : answers [ msg [ \"from\" ]] = msg if expect is not None and msg [ \"from\" ] in expect : expect . remove ( msg [ \"from\" ]) elif not msg : break now = time . time () send ( self , to , seq , msg_type , data = {}) Send message to drone Parameters: Name Type Description Default to str receiving group required seq int sequence number required msg_type str type of message to receive required data dict data to send to node {} Source code in udronerc/dronehost.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def send ( self , to : str , seq : int , msg_type : str , data : dict = {}): \"\"\" Send message to drone Args: to (str): receiving group seq (int): sequence number msg_type (str): type of message to receive data (dict): data to send to node \"\"\" msg = { \"from\" : self . hostid , \"to\" : to , \"type\" : msg_type , \"seq\" : seq , \"data\" : data , } packet = json . dumps ( msg , separators = ( \",\" , \":\" )) logger . debug ( f \"Sending: { packet } \" ) self . socket . sendto ( packet . encode ( \"utf-8\" ), self . addr ) whois ( self , group , need = None , seq = None , board = None ) Return online drones Parameters: Name Type Description Default group str limit request to specific group required need int minimum number of ansers None seq int sequence number None board str limit request to specific board None Returns: Type Description dict dict: received answers of boards Source code in udronerc/dronehost.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def whois ( self , group : str , need : int = None , seq : int = None , board : str = None ) -> dict : \"\"\" Return online drones Args: group (str): limit request to specific group need (int): minimum number of ansers seq (int): sequence number board (str): limit request to specific board Returns: dict: received answers of boards \"\"\" answers = {} if seq is None : seq = self . genseq () for timeout in self . resent_strategy : data = {} if board : data [ \"board\" ] = board self . send ( group , seq , \"!whois\" , data ) if need == 0 : break self . recv_until ( answers , seq , \"status\" , timeout ) if need and len ( answers ) >= need : break return answers","title":"Dronehost"},{"location":"reference/dronehost/#udronerc.dronehost","text":"","title":"udronerc.dronehost"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost","text":"","title":"DroneHost"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.call","text":"Send data to drone and receive response Parameters: Name Type Description Default to str selected group required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None expect list list of drones expected to anser None Returns: Type Description dict dict: received message from drones Source code in udronerc/dronehost.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def call ( self , to : str , seq : int , msg_type : str , data : dict = None , resp_type : str = None , expect : list = None , ) -> dict : \"\"\" Send data to drone and receive response Args: to (str): selected group seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type expect (list): list of drones expected to anser Returns: dict: received message from drones \"\"\" if not seq : seq = self . genseq () answers = {} for timeout in self . resent_strategy : self . send ( to , seq , msg_type , data ) self . recv_until ( answers , seq , resp_type , timeout , expect ) if expect is not None and len ( expect ) == 0 : break return answers","title":"call()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.call_multi","text":"Send data to multiple drones and receive responses Parameters: Name Type Description Default nodes list selected drones required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None Returns: Type Description dict dict: received message from drones Source code in udronerc/dronehost.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def call_multi ( self , nodes : list , seq : int , msg_type : str , data : dict = None , resp_type : str = None , ) -> dict : \"\"\" Send data to multiple drones and receive responses Args: nodes (list): selected drones seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type Returns: dict: received message from drones \"\"\" if not seq : seq = self . genseq () answers = {} for timeout in self . resent_strategy : for node in nodes : self . send ( node , seq , msg_type , data ) self . recv_until ( answers , seq , resp_type , timeout , nodes ) if len ( nodes ) == 0 : break return answers","title":"call_multi()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.genseq","text":"Generate random sequence number Returns: Type Description int int: generated sequence Source code in udronerc/dronehost.py 65 66 67 68 69 70 71 72 def genseq ( self ) -> int : \"\"\" Generate random sequence number Returns: int: generated sequence \"\"\" return struct . unpack ( \"=I\" , os . urandom ( 4 ))[ 0 ] % 2000000000","title":"genseq()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.get_ip_address","text":"Get IP of a local interface Parameters: Name Type Description Default interface str name of local interface required Returns: Type Description str str: IP address of interface Source code in udronerc/dronehost.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_ip_address ( self , interface : str ) -> str : \"\"\" Get IP of a local interface Args: interface (str): name of local interface Returns: str: IP address of interface \"\"\" s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) return socket . inet_ntoa ( fcntl . ioctl ( s . fileno (), 0x8915 , struct . pack ( \"256s\" , interface [: 15 ] . encode ( \"utf-8\" )), # SIOCGIFADDR )[ 20 : 24 ] )","title":"get_ip_address()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.Group","text":"Create new group Parameters: Name Type Description Default groupid str Name of the new group required absolute bool Prefix group name with hostid False Returns: Type Description Group Newly created group Source code in udronerc/dronehost.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def Group ( self , groupid : str , absolute : bool = False ): \"\"\"Create new group Args: groupid (str): Name of the new group absolute (bool): Prefix group name with hostid Returns: Group: Newly created group \"\"\" if not absolute : groupid = f \" { self . hostid } _ { groupid } \" group = DroneGroup ( self , groupid ) self . groups . append ( group ) return group","title":"Group()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.recv","text":"Recevie messages from drones Parameters: Name Type Description Default seq int sequence number required msg_type str type of message to receive None Returns: Type Description dict dict: received message from drone Source code in udronerc/dronehost.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def recv ( self , seq : int , msg_type : str = None ) -> dict : \"\"\" Recevie messages from drones Args: seq (int): sequence number msg_type (str): type of message to receive Returns: dict: received message from drone \"\"\" while True : try : msg = json . loads ( self . socket . recv ( self . maxsize )) if ( msg [ \"from\" ] and msg [ \"type\" ] and msg [ \"to\" ] == self . hostid and ( not msg_type or msg [ \"type\" ] == msg_type ) and ( not seq or msg [ \"seq\" ] == seq ) ): logger . debug ( \"Received: %s \" , str ( msg )) return msg except Exception as e : if isinstance ( e , socket . error ) and e . errno == EWOULDBLOCK : return None","title":"recv()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.recv_until","text":"Recevie messages from drones until requirement is fulfilled Parameters: Name Type Description Default answers dict Empty dict to be filled with received answers required seq int sequence number required msg_type str type of message to receive None timeout int number of seconds before receiving timeouts 1 expect list list of drones expected to anser None Source code in udronerc/dronehost.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def recv_until ( self , answers : dict , seq : int , msg_type : str = None , timeout : int = 1 , expect : list = None , ): \"\"\" Recevie messages from drones until requirement is fulfilled Args: answers (dict): Empty dict to be filled with received answers seq (int): sequence number msg_type (str): type of message to receive timeout (int): number of seconds before receiving timeouts expect (list): list of drones expected to anser \"\"\" logger . debug ( \"Receiving replies for seq %i for %.1f secs expecting %s \" , seq , timeout , expect , ) start = time . time () now = start while ( ( now - start ) >= 0 and ( now - start ) < timeout and ( expect is None or len ( expect ) > 0 ) ): self . poll . poll (( timeout - ( now - start )) * 1000 ) while True : msg = self . recv ( seq , msg_type ) if msg : answers [ msg [ \"from\" ]] = msg if expect is not None and msg [ \"from\" ] in expect : expect . remove ( msg [ \"from\" ]) elif not msg : break now = time . time ()","title":"recv_until()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.send","text":"Send message to drone Parameters: Name Type Description Default to str receiving group required seq int sequence number required msg_type str type of message to receive required data dict data to send to node {} Source code in udronerc/dronehost.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def send ( self , to : str , seq : int , msg_type : str , data : dict = {}): \"\"\" Send message to drone Args: to (str): receiving group seq (int): sequence number msg_type (str): type of message to receive data (dict): data to send to node \"\"\" msg = { \"from\" : self . hostid , \"to\" : to , \"type\" : msg_type , \"seq\" : seq , \"data\" : data , } packet = json . dumps ( msg , separators = ( \",\" , \":\" )) logger . debug ( f \"Sending: { packet } \" ) self . socket . sendto ( packet . encode ( \"utf-8\" ), self . addr )","title":"send()"},{"location":"reference/dronehost/#udronerc.dronehost.DroneHost.whois","text":"Return online drones Parameters: Name Type Description Default group str limit request to specific group required need int minimum number of ansers None seq int sequence number None board str limit request to specific board None Returns: Type Description dict dict: received answers of boards Source code in udronerc/dronehost.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def whois ( self , group : str , need : int = None , seq : int = None , board : str = None ) -> dict : \"\"\" Return online drones Args: group (str): limit request to specific group need (int): minimum number of ansers seq (int): sequence number board (str): limit request to specific board Returns: dict: received answers of boards \"\"\" answers = {} if seq is None : seq = self . genseq () for timeout in self . resent_strategy : data = {} if board : data [ \"board\" ] = board self . send ( group , seq , \"!whois\" , data ) if need == 0 : break self . recv_until ( answers , seq , \"status\" , timeout ) if need and len ( answers ) >= need : break return answers","title":"whois()"},{"location":"reference/modules/checkip/","text":"checkip ( group , interface = 'lan' , check_ipv4 = True , check_ipv6 = False , specific_ipv4 = 'any' , specific_ipv6 = 'any' ) Check drone IP state on specified interface Parameters: Name Type Description Default group DroneGroup Group with drones to check required interface str Interface name to check for IP 'lan' check_ipv4 bool Check if interface has IPv4 address True check_ipv6 bool Check if interface has iPv6 address False specific_ipv4 str IPv4 that specific be assigned to interface 'any' specific_ipv6 str IPv6 that specific be assigned to interface 'any' Source code in udronerc/modules/checkip.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def checkip ( group : DroneGroup , interface = \"lan\" , check_ipv4 : bool = True , check_ipv6 : bool = False , specific_ipv4 : str = \"any\" , specific_ipv6 : str = \"any\" , ): \"\"\"Check drone IP state on specified interface Args: group (DroneGroup): Group with drones to check interface (str): Interface name to check for IP check_ipv4 (bool): Check if interface has IPv4 address check_ipv6 (bool): Check if interface has iPv6 address specific_ipv4 (str): IPv4 that specific be assigned to interface specific_ipv6 (str): IPv6 that specific be assigned to interface \"\"\" logger . debug ( f \" { interface =} { ipv4 =} { ipv6 =} \" ) success = {} responses = group . call ( \"ubus\" , { \"path\" : f \"network.interface. { interface } \" , \"method\" : \"status\" } ) for response in responses : success [ response [ \"from\" ]] = True if check_ipv4 : ipv4_addresses = response [ \"data\" ] . get ( \"ipv4-address\" , []) if not specific_ipv4 : if len ( ipv4_addresses ) > 0 : success [ response [ \"from\" ]] = False else : found = False for ip in ipv4_addresses : if ip [ \"address\" ] == specific_ipv4 : found = True if not found : success [ response [ \"from\" ]] = False if check_ipv6 : ipv6_addresses = response [ \"data\" ] . get ( \"ipv6-address\" , []) if not specifc_ipv6 : if len ( ipv6_addresses ) > 0 : success [ response [ \"from\" ]] = False else : found = False for ip in ipv6_addresses : if ip [ \"address\" ] == ipv6 : found = True if not found : success [ response [ \"from\" ]] = False return success","title":"Checkip"},{"location":"reference/modules/checkip/#udronerc.modules.checkip","text":"","title":"udronerc.modules.checkip"},{"location":"reference/modules/checkip/#udronerc.modules.checkip.checkip","text":"Check drone IP state on specified interface Parameters: Name Type Description Default group DroneGroup Group with drones to check required interface str Interface name to check for IP 'lan' check_ipv4 bool Check if interface has IPv4 address True check_ipv6 bool Check if interface has iPv6 address False specific_ipv4 str IPv4 that specific be assigned to interface 'any' specific_ipv6 str IPv6 that specific be assigned to interface 'any' Source code in udronerc/modules/checkip.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def checkip ( group : DroneGroup , interface = \"lan\" , check_ipv4 : bool = True , check_ipv6 : bool = False , specific_ipv4 : str = \"any\" , specific_ipv6 : str = \"any\" , ): \"\"\"Check drone IP state on specified interface Args: group (DroneGroup): Group with drones to check interface (str): Interface name to check for IP check_ipv4 (bool): Check if interface has IPv4 address check_ipv6 (bool): Check if interface has iPv6 address specific_ipv4 (str): IPv4 that specific be assigned to interface specific_ipv6 (str): IPv6 that specific be assigned to interface \"\"\" logger . debug ( f \" { interface =} { ipv4 =} { ipv6 =} \" ) success = {} responses = group . call ( \"ubus\" , { \"path\" : f \"network.interface. { interface } \" , \"method\" : \"status\" } ) for response in responses : success [ response [ \"from\" ]] = True if check_ipv4 : ipv4_addresses = response [ \"data\" ] . get ( \"ipv4-address\" , []) if not specific_ipv4 : if len ( ipv4_addresses ) > 0 : success [ response [ \"from\" ]] = False else : found = False for ip in ipv4_addresses : if ip [ \"address\" ] == specific_ipv4 : found = True if not found : success [ response [ \"from\" ]] = False if check_ipv6 : ipv6_addresses = response [ \"data\" ] . get ( \"ipv6-address\" , []) if not specifc_ipv6 : if len ( ipv6_addresses ) > 0 : success [ response [ \"from\" ]] = False else : found = False for ip in ipv6_addresses : if ip [ \"address\" ] == ipv6 : found = True if not found : success [ response [ \"from\" ]] = False return success","title":"checkip()"}]}